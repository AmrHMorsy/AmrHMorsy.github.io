<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Poisson-Disk Sampling | Amr Morsy</title> <meta name="author" content="Amr Morsy"> <meta name="description" content="Sampling Algorithm"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?9d668792a35ea38530ac52abca49b388"> <link rel="apple-touch-icon" href="/assets/img/apple-touch-icon.png"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://amrhmorsy.github.io/blog/2026/PoissonDiskSampling/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Amr </span>Morsy</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/index.html">Blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/portfolio/">Portfolio</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Poisson-Disk Sampling</h1> <p class="post-meta">January 5, 2026</p> <p class="post-tags"> <a href="/blog/2026"> <i class="fa-solid fa-calendar fa-sm"></i> 2026 </a> </p> </header> <article class="post-content"> <blogpost id="markdown-content"> <p><br></p> <p><strong>Poisson-Disk sampling</strong> is an algorithm used to generate random samples within a user-defined domain, such that each two points are seperated by a minimum distance \(r\). It produces a well-distributed set of random samples that are tightly-packed, yet not clumped or clustered together.</p> <p><br></p> <h4 id="dart-throwing-algorithm-"> <strong>Dart-Throwing Algorithm</strong> <br> </h4> <p><br></p> <p>One <strong>naive</strong> implementation of Poisson-Disk sampling is the <strong>dart-throwing algorithm</strong>. It is described as follows:</p> <ol> <li> <p>Initialize an empty set \(S\). This set will contain the final sample points.</p> </li> <li> <p>While \(|S| &lt; N\):</p> <ul> <li> <p>Generate a random sample \(P\) within \(E\).</p> </li> <li> <p>Check the distance \(d_i\) between \(P\) and each point \(s_i\) in \(S\). If there is at least one point \(s_i\) in \(S\) where \(d_i &lt; r\), then we discard \(P\) and try again with a new point. Otherwise, \(P\) is added to \(S\).</p> </li> </ul> </li> </ol> <blockquote> <p>One problem with this algorithm is that at some point when the area is fully saturated, and there are still remaining samples to be generated, it might be impossible for any newly generated point to be approved, causing the algorithm to potentially run forever. Hence, as a precaution, a maximum number of attempts \(A\) is enforced, where \(A &gt;= N\). If all \(A\) attempts are used, then the algorithm will terminate regardless of whether \(N\) approved sample points were generated or not.</p> </blockquote> <p>Below is an <strong>C++</strong> implementation of the dart-throwing algorithm:</p> <p><br></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">D</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">PoissonDisk</span><span class="p">{</span>
    
<span class="nl">private:</span>
    
    <span class="k">static</span> <span class="kt">float</span> <span class="n">Length</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">length</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Subtract</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">float</span> <span class="nf">Random</span><span class="p">(</span><span class="kt">float</span> <span class="n">min</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">rng</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="p">{}());</span>
        <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="nf">dist</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Random</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
                            
<span class="k">public</span><span class="o">:</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&gt;</span> <span class="n">Generate</span><span class="p">(</span><span class="kt">int</span> <span class="n">numSamples</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxNumAttempts</span><span class="p">,</span> <span class="kt">float</span> <span class="n">minDistance</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&gt;</span> <span class="n">samples</span><span class="p">;</span>
    
        <span class="kt">int</span> <span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">((</span><span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">numSamples</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">attempt</span> <span class="o">&lt;</span> <span class="n">maxNumAttempts</span><span class="p">)){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">point</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
            
            <span class="kt">bool</span> <span class="n">approved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">Length</span><span class="p">(</span><span class="n">Subtract</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="p">){</span>
                    <span class="n">approved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">approved</span><span class="p">)</span>
                <span class="n">samples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
                
            <span class="n">attempt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    
        <span class="k">return</span> <span class="n">samples</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p><br></p> <p>As discussed before, the Dart-Throwing algorithm is naive and inefficient. The best-case scenario for the algorithm happens when each generated point \(P\) is approved and added to the set \(S\). That is, the best-case time complexity of the algorithm is</p> \[T(N) = \sum_{k=1}^N k = \frac{N(N+1)}{2} = \Omega(N^2)\] <p>The worst-case scenario for the algorithm happens when \(N-1\) points are generated and approved, and the \(N^{th}\) point keeps getting rejected till the \(A-N+1\) attempts left are used and the algorithm terminates. That is, the worst-case time complexity of the algorithm is</p> \[T(N) = \sum_{k=1}^{N-1} k + (A-N+1)(N-1)\] \[= \frac{(N-1)(N-2)}{2} + (AN - A - N^2 + N + N - 1)\] \[= \frac{N^2}{2} - \frac{3N}{2} + 1 + AN - A - N^2 + 2N - 1\] \[= \frac{N^2}{2} - \frac{3N}{2} + AN - A - N^2 + 2N\] \[= -\frac{N^2}{2} + (\frac{1}{2} + A)N - A\] \[= O(N^2) + O(AN)\] \[= O(AN)\] <p><br></p> <h4 id="bridsons-algorithm-"> <strong>Bridson’s Algorithm</strong> <br> </h4> <p><br></p> <p><strong>Bridson’s algorithm</strong> is another technique for implementing Poisson disk sampling that is much more efficient than the dart-throwing algorithm. It is described as follows:</p> <p><br> The algorithm takes as input the extent \(E\) of the sample domain in \(R^n\), the minimum distance \(r\) between samples, and a constant \(k\).</p> <ol> <li> <p>Initialize an \(n\)-dimensional grid \(G\) with cell size \(\frac{r}{\sqrt(n)}\). Each cell in the grid \(G\) will contain only <strong>one</strong> sample.</p> </li> <li> <p>Initialize an empty set \(A\). This set will contain the “active samples”.</p> </li> <li> <p>Initialize another empty set \(S\). This set will contain the final sample points.</p> </li> <li> <p>Generate an initial sample \(x \in E\) and add it \(A\), \(S\) and \(G\).</p> </li> <li> <p>While \(A\) is non-empty:</p> <ul> <li> <p>Randomly choose sample \(a_i \in A\).</p> </li> <li> <p>Generate \(k\) random candidate samples \(\{ w_1, w_2, ...., w_k\}\) from the spherical annulus between radius \(r\) and \(2r\) around \(a_i\)</p> </li> <li> <p>For each candidate \(w_j\):</p> <ul> <li> <p>Locate the cell in \(G\) in which \(w_j\) will be stored. Say the cell is \(C_j\)</p> </li> <li> <p>Around \(C_j\), there are \(3^n - 1\) distinct neighbouring cells. Each one of these cells is either empty or have one existing sample \(q_m\).</p> </li> <li> <p>For each sample \(q_m\):</p> <ul> <li> <p>Calculate its distance from \(w_j\).</p> </li> <li> <p>If the distance is less than \(r\), then \(w_j\) is rejected.</p> </li> </ul> </li> <li> <p>If all the samples \(q_m\) were adequately far from \(w_j\), then \(w_j\) is approved, and is added to \(S\), \(A\) and \(G\).</p> </li> </ul> </li> <li> <p>If all the candidates \(w_j\) were rejected, then remove \(a_i\) from \(A\).</p> </li> </ul> </li> </ol> <blockquote> Each cell in the grid \(G\) has \(3^n - 1\) <b>distinct</b> neighbors. <br> <br> <b><b>Proof</b></b> <br> <br> Let \(C\) be a cell in \(G\) with index \(i\), such that $$ i = (i_1, i_2, ......, i_n) $$ A cell with index \(j\) is a neighbor to \(C\) if and only if $$ \forall_{1 \, \leq \, k \, \leq \, n} \; \; j_k = i_k ± d $$ where \(d \in \{ -1, 0, 1\} \). That is, <br> <br> <ul><li> If \(d = -1\), then we get the previous cell in dimension \(k\)</li></ul> <ul><li> If \(d = 0\), then we get the same cell in dimension \(k\)</li></ul> <ul><li> If \(d = 1\), then we get the next cell in dimension \(k\)</li></ul> <br> This means that for every dimension \(1 \, \leq \, k \, \leq \, n\), there are \(3\) neighboring cells. Hence, the total number of neighbors to \(C\) is $$ 3 \times 3 \times ... \times 3 = 3^n $$ However, this count includes the cell \(C\) itself, which is the case when \(d = 0\) in all \(k\) dimensions. Thus, the total number of <b>distinct</b> neighbors is $$ 3^n - 1 $$ \(\blacksquare\) </blockquote> <p><br></p> <p>Let \(C\) be a cell in \(G\) with index \(i = (i_1, i_2, ......, i_n)\). We know that \(C\) has \(3^n\) neighbors \(\{N_1, N_2, ..., N_{3^n -1}\}\), including \(C\) itself. We can calculate the cell index of \(N_j\) using the following function:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">ComputeNeighborCellIndex</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">j</span> <span class="o">/=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The idea of this function is that we represent each index \(j\), where \(1 \leq j \leq 3^n\) as a base-3 number (Ternary). Then using this ternary representation, we extract the offset \(d\) by subtracing \(1\) from every digit. This offset will be added to the index of cell \(C\) to calculate the index of the neighbouring cell. That is,</p> <p><br></p> <table> <thead> <tr> <th>Decimal</th> <th>Ternary</th> <th>Offset</th> </tr> </thead> <tbody> <tr> <td>\(0\)</td> <td>\(000\)</td> <td>\(\{-1, -1, -1\}\)</td> </tr> <tr> <td>\(1\)</td> <td>\(001\)</td> <td>\(\{-1, -1, 0\}\)</td> </tr> <tr> <td>\(2\)</td> <td>\(002\)</td> <td>\(\{-1, -1, 1\}\)</td> </tr> <tr> <td>\(3\)</td> <td>\(010\)</td> <td>\(\{-1, 0, -1\}\)</td> </tr> <tr> <td>\(4\)</td> <td>\(011\)</td> <td>\(\{-1, 0, 0\}\)</td> </tr> <tr> <td>\(5\)</td> <td>\(012\)</td> <td>\(\{-1, 0, 1\}\)</td> </tr> <tr> <td>\(6\)</td> <td>\(020\)</td> <td>\(\{-1, 1, -1\}\)</td> </tr> <tr> <td>\(7\)</td> <td>\(021\)</td> <td>\(\{-1, 1, 0\}\)</td> </tr> <tr> <td>\(8\)</td> <td>\(022\)</td> <td>\(\{-1, 1, 1\}\)</td> </tr> <tr> <td>\(9\)</td> <td>\(100\)</td> <td>\(\{0, -1, -1\}\)</td> </tr> <tr> <td>\(10\)</td> <td>\(101\)</td> <td>\(\{0, -1, 0\}\)</td> </tr> </tbody> </table> <p><br></p> <blockquote> The size of each cell in the grid \(G\) must be at most \(\frac{r}{\sqrt(n)}\). <br> <br> <b><b>Proof</b></b> <br> <br> We know that the distance between any two points must be at least \(r\). We also know that each cell in the grid \(G\) must have only one point. Consider the cell \(C\) in \(G\). Let \(d\) be the length of the diagonal of \(C\) and \(s\) be its cell size. Suppose for the sake of contradiction that \(d &gt; r\). This means that two points can be placed inside \(C\) whose distance is greater than or equal to \(r\). This violates the requirement that each cell in the grid \(G\) must have only one point. Thus, \(d \leq r\). <div class="row align-items-center mt-3"> <div class="col-md-10"> <br> <br> Now, using Pythagoras theorem: $$ d^2 = s_1^2 + s_2^2 + ...... + s_n^2 = n \; s^2 $$ $$ s^2 = \frac{d^2}{n} $$ $$ s = \sqrt(\frac{d^2}{n}) = \frac{d}{\sqrt(n)} $$ Since \(d \leq r\), then $$ s \leq \frac{r}{\sqrt(n)} $$ </div> <div class="col-md-2"> <figure class="col-md-6 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PoissonDiskSampling/Dark/1-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PoissonDiskSampling/Dark/1-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PoissonDiskSampling/Dark/1-1400.webp"></source> <img src="/assets/img/Blog/PoissonDiskSampling/Dark/1.png" width="300" height="300" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </figure> <figure class="col-md-6 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PoissonDiskSampling/Light/1-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PoissonDiskSampling/Light/1-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PoissonDiskSampling/Light/1-1400.webp"></source> <img src="/assets/img/Blog/PoissonDiskSampling/Light/1.png" width="300" height="300" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </figure> </div> </div> \(\blacksquare\) </blockquote> <p><br></p> <p><strong>Bridson’s</strong> algorithm is much faster than the <strong>dart-throwing</strong> algorithm. The number of iterations of the loop in Step \(5\) is exactly \(2N-1\), where \(N\) is the number of samples. Each iteration takes \(O(k)\) time. This means that the time complexity \(T(N)\) of the algorithm is</p> \[T(N) = k(2N-1) = 2kN - k = O(2kN) - O(k) = O(kN)\] <p>Since \(k\) is constant, then \(T(N) = O(N)\) time. That is, the algorithm is <strong>linear</strong>.</p> <blockquote> Step \(5\) is executed exaclty \(2N-1\) times. <br> <br> <b><b>Proof</b></b> <br> <br> The loop in step \(5\) of the algorithm terminates only if the active set \(A\) is empty. For each iteration of the loop, exactly <b>one</b> of the following <b>two</b> events occur: <br> <br> <ul><li> A new sample is added to \(A\)</li></ul> <ul><li> An existing active sample is removed from \(A\)</li></ul> <br> Each sample point \(s_i \in S\) must <b>once</b> be added to \(A\) and <b>once</b> be removed from \(A\). After it is removal from \(A\), it can never be readded back into \(A\). This means that the total number of insertions is \(N\) and the total number of removals is \(N\). Since only one event happens in each iteration of the loop, then the number of iterations of the loop is \(2N\). However, the insertion of the first sample \(x\) into \(A\) is done in step \(4\) before the loop. Thus, the total number of iterations of the loop in step \(5\) is exactly \(2N-1\). <br> <br> \(\blacksquare\) <br> </blockquote> <p><br></p> <p>Below is a full C++ implementation of <strong>Bridson’s</strong> algorithm:</p> <p><br></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp">
</span>


<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">D</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">PoissonDisk</span><span class="p">{</span>
    
<span class="nl">private:</span>
    
    <span class="k">static</span> <span class="kt">float</span> <span class="n">Length</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">length</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="kt">float</span> <span class="nf">Random</span><span class="p">(</span><span class="kt">float</span> <span class="n">min</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">rng</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="p">{}());</span>
        <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="nf">dist</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Random</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Normalize</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        
        <span class="kt">float</span> <span class="n">length</span> <span class="o">=</span> <span class="n">Length</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mf">0.0f</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">length</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">RandomWithinSphericalAnnulus</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">sample</span><span class="p">,</span> <span class="kt">float</span> <span class="n">minDistance</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">minDir</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">minDir</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">;</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">maxDir</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">maxDir</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">randomDir</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">Random</span><span class="p">(</span><span class="n">minDir</span><span class="p">,</span> <span class="n">maxDir</span><span class="p">));</span>
        
        <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="n">minDistance</span><span class="p">,</span> <span class="mf">2.0f</span> <span class="o">*</span> <span class="n">minDistance</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">newSample</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">newSample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">randomDir</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">newSample</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Subtract</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">ComputeGridIndex</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">sample</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cellSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">gridIndex</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">gridIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">cellSize</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">gridIndex</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">ComputeNeighborGridIndex</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rank</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">rank</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">neighborIndex</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">){</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">tmp</span> <span class="o">/=</span> <span class="mi">3</span><span class="p">;</span>
            <span class="n">neighborIndex</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">neighborIndex</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">ComputeFlattenedGridIndex</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">gridIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">gridResolutions</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">flattenedGridIndex</span> <span class="o">=</span> <span class="n">gridIndex</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">gridResolutions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">flattenedGridIndex</span> <span class="o">+=</span> <span class="p">(</span><span class="n">gridIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">stride</span><span class="p">);</span>
            <span class="n">stride</span> <span class="o">*=</span> <span class="n">gridResolutions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">flattenedGridIndex</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">ComputeGridResolutions</span><span class="p">(</span><span class="kt">float</span> <span class="n">cellSize</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">gridResolutions</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">gridResolutions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">((</span><span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">cellSize</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">gridResolutions</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">ComputeTotalNumGridCells</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">gridResolutions</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">totalNumGridCells</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">totalNumGridCells</span> <span class="o">*=</span> <span class="n">gridResolutions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">return</span> <span class="n">totalNumGridCells</span><span class="p">;</span>
    <span class="p">}</span>
        
<span class="k">public</span><span class="o">:</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&gt;</span> <span class="n">Generate</span><span class="p">(</span><span class="kt">int</span> <span class="n">numSamples</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxNumAttempts</span><span class="p">,</span> <span class="kt">float</span> <span class="n">minDistance</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">numNeighbors</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">D</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">cellSize</span> <span class="o">=</span> <span class="n">minDistance</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">gridResolutions</span> <span class="o">=</span> <span class="n">ComputeGridResolutions</span><span class="p">(</span><span class="n">cellSize</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
        
        <span class="kt">int</span> <span class="n">totalNumGridCells</span> <span class="o">=</span> <span class="n">ComputeTotalNumGridCells</span><span class="p">(</span><span class="n">gridResolutions</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">initialSample</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">initialSample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">;</span>                
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">initialSampleGridIndex</span> <span class="o">=</span> <span class="n">ComputeGridIndex</span><span class="p">(</span><span class="n">initialSample</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">initialSampleFlattenedGridIndex</span> <span class="o">=</span> <span class="n">ComputeFlattenedGridIndex</span><span class="p">(</span><span class="n">initialSampleGridIndex</span><span class="p">,</span> <span class="n">gridResolutions</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&gt;</span> <span class="n">samples</span><span class="p">;</span>
        <span class="n">samples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">initialSample</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">activeSamples</span><span class="p">;</span>
        <span class="n">activeSamples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">totalNumGridCells</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">initialSampleFlattenedGridIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">activeSamples</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">numSamples</span><span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">activeSamples</span><span class="p">[</span><span class="n">activeSamples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">]];</span>
            
            <span class="kt">bool</span> <span class="n">retire</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxNumAttempts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">RandomWithinSphericalAnnulus</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">minDistance</span><span class="p">);</span>
                                
                <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">candidateGridIndex</span> <span class="o">=</span> <span class="n">ComputeGridIndex</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">candidateFlattenedGridIndex</span> <span class="o">=</span> <span class="n">ComputeFlattenedGridIndex</span><span class="p">(</span><span class="n">candidateGridIndex</span><span class="p">,</span> <span class="n">gridResolutions</span><span class="p">);</span>
                
                <span class="kt">bool</span> <span class="n">candidateApproved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">numNeighbors</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">){</span>
                    
                    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">neighborGridIndex</span> <span class="o">=</span> <span class="n">ComputeNeighborGridIndex</span><span class="p">(</span><span class="n">candidateGridIndex</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
                    
                    <span class="k">if</span><span class="p">(</span><span class="n">neighborGridIndex</span> <span class="o">==</span> <span class="n">candidateGridIndex</span><span class="p">)</span>
                        <span class="k">continue</span><span class="p">;</span>
                    
                    <span class="kt">int</span> <span class="n">neighborFlattenedGridIndex</span> <span class="o">=</span> <span class="n">ComputeFlattenedGridIndex</span><span class="p">(</span><span class="n">neighborGridIndex</span><span class="p">,</span> <span class="n">gridResolutions</span><span class="p">);</span>
                                        
                    <span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">neighborFlattenedGridIndex</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">continue</span><span class="p">;</span>
                    
                    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">neighborFlattenedGridIndex</span><span class="p">]];</span>
                    
                    <span class="k">if</span><span class="p">(</span><span class="n">Length</span><span class="p">(</span><span class="n">Subtract</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">candidate</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="p">){</span>
                        <span class="n">candidateApproved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                
                <span class="k">if</span><span class="p">(</span><span class="n">candidateApproved</span><span class="p">){</span>
                    <span class="n">samples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">candidate</span><span class="p">);</span>
                    <span class="n">activeSamples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">candidateFlattenedGridIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">retire</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">retire</span><span class="p">)</span>
                <span class="n">activeSamples</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">samples</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p><br></p> <hr> <p><br></p> <h4 id="references-"> <strong>References</strong> <br> </h4> <p><br></p> <p><strong>[1]</strong> <a href="https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf" rel="external nofollow noopener" target="_blank">Fast Poisson Disk Sampling in Arbitrary Dimensions by Robert Bridson</a></p> </blogpost> </article> </div> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>