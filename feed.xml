<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://amrhmorsy.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://amrhmorsy.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-02-17T12:41:33+00:00</updated><id>https://amrhmorsy.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Poisson-Disk Sampling</title><link href="https://amrhmorsy.github.io/blog/2026/PoissonDiskSampling/" rel="alternate" type="text/html" title="Poisson-Disk Sampling"/><published>2026-01-05T09:00:00+00:00</published><updated>2026-01-05T09:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2026/PoissonDiskSampling</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2026/PoissonDiskSampling/"><![CDATA[<p><br/></p> <p><strong>Poisson-Disk sampling</strong> is an algorithm used to generate random samples within a user-defined domain, such that each two points are seperated by a minimum distance \(r\). It produces a well-distributed set of random samples that are tightly-packed, yet not clumped or clustered together.</p> <p><br/></p> <h4 id="dart-throwing-algorithm-"><strong>Dart-Throwing Algorithm</strong> <br/></h4> <p><br/></p> <p>One <strong>naive</strong> implementation of Poisson-Disk sampling is the <strong>dart-throwing algorithm</strong>. It is described as follows:</p> <ol> <li> <p>Initialize an empty set \(S\). This set will contain the final sample points.</p> </li> <li> <p>While \(|S| &lt; N\):</p> <ul> <li> <p>Generate a random sample \(P\) within \(E\).</p> </li> <li> <p>Check the distance \(d_i\) between \(P\) and each point \(s_i\) in \(S\). If there is at least one point \(s_i\) in \(S\) where \(d_i &lt; r\), then we discard \(P\) and try again with a new point. Otherwise, \(P\) is added to \(S\).</p> </li> </ul> </li> </ol> <blockquote> <p>One problem with this algorithm is that at some point when the area is fully saturated, and there are still remaining samples to be generated, it might be impossible for any newly generated point to be approved, causing the algorithm to potentially run forever. Hence, as a precaution, a maximum number of attempts \(A\) is enforced, where \(A &gt;= N\). If all \(A\) attempts are used, then the algorithm will terminate regardless of whether \(N\) approved sample points were generated or not.</p> </blockquote> <p>Below is an <strong>C++</strong> implementation of the dart-throwing algorithm:</p> <p><br/></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">D</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">PoissonDisk</span><span class="p">{</span>
    
<span class="nl">private:</span>
    
    <span class="k">static</span> <span class="kt">float</span> <span class="n">Length</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">length</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Subtract</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">float</span> <span class="nf">Random</span><span class="p">(</span><span class="kt">float</span> <span class="n">min</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">rng</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="p">{}());</span>
        <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="nf">dist</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Random</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
                            
<span class="k">public</span><span class="o">:</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&gt;</span> <span class="n">Generate</span><span class="p">(</span><span class="kt">int</span> <span class="n">numSamples</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxNumAttempts</span><span class="p">,</span> <span class="kt">float</span> <span class="n">minDistance</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&gt;</span> <span class="n">samples</span><span class="p">;</span>
    
        <span class="kt">int</span> <span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">((</span><span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">numSamples</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">attempt</span> <span class="o">&lt;</span> <span class="n">maxNumAttempts</span><span class="p">)){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">point</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
            
            <span class="kt">bool</span> <span class="n">approved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">Length</span><span class="p">(</span><span class="n">Subtract</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="p">){</span>
                    <span class="n">approved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">approved</span><span class="p">)</span>
                <span class="n">samples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
                
            <span class="n">attempt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    
        <span class="k">return</span> <span class="n">samples</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p><br/></p> <p>As discussed before, the Dart-Throwing algorithm is naive and inefficient. The best-case scenario for the algorithm happens when each generated point \(P\) is approved and added to the set \(S\). That is, the best-case time complexity of the algorithm is</p> \[T(N) = \sum_{k=1}^N k = \frac{N(N+1)}{2} = \Omega(N^2)\] <p>The worst-case scenario for the algorithm happens when \(N-1\) points are generated and approved, and the \(N^{th}\) point keeps getting rejected till the \(A-N+1\) attempts left are used and the algorithm terminates. That is, the worst-case time complexity of the algorithm is</p> \[T(N) = \sum_{k=1}^{N-1} k + (A-N+1)(N-1)\] \[= \frac{(N-1)(N-2)}{2} + (AN - A - N^2 + N + N - 1)\] \[= \frac{N^2}{2} - \frac{3N}{2} + 1 + AN - A - N^2 + 2N - 1\] \[= \frac{N^2}{2} - \frac{3N}{2} + AN - A - N^2 + 2N\] \[= -\frac{N^2}{2} + (\frac{1}{2} + A)N - A\] \[= O(N^2) + O(AN)\] \[= O(AN)\] <p><br/></p> <h4 id="bridsons-algorithm-"><strong>Bridson’s Algorithm</strong> <br/></h4> <p><br/></p> <p><strong>Bridson’s algorithm</strong> is another technique for implementing Poisson disk sampling that is much more efficient than the dart-throwing algorithm. It is described as follows:</p> <p><br/> The algorithm takes as input the extent \(E\) of the sample domain in \(R^n\), the minimum distance \(r\) between samples, and a constant \(k\).</p> <ol> <li> <p>Initialize an \(n\)-dimensional grid \(G\) with cell size \(\frac{r}{\sqrt(n)}\). Each cell in the grid \(G\) will contain only <strong>one</strong> sample.</p> </li> <li> <p>Initialize an empty set \(A\). This set will contain the “active samples”.</p> </li> <li> <p>Initialize another empty set \(S\). This set will contain the final sample points.</p> </li> <li> <p>Generate an initial sample \(x \in E\) and add it \(A\), \(S\) and \(G\).</p> </li> <li> <p>While \(A\) is non-empty:</p> <ul> <li> <p>Randomly choose sample \(a_i \in A\).</p> </li> <li> <p>Generate \(k\) random candidate samples \(\{ w_1, w_2, ...., w_k\}\) from the spherical annulus between radius \(r\) and \(2r\) around \(a_i\)</p> </li> <li> <p>For each candidate \(w_j\):</p> <ul> <li> <p>Locate the cell in \(G\) in which \(w_j\) will be stored. Say the cell is \(C_j\)</p> </li> <li> <p>Around \(C_j\), there are \(3^n - 1\) distinct neighbouring cells. Each one of these cells is either empty or have one existing sample \(q_m\).</p> </li> <li> <p>For each sample \(q_m\):</p> <ul> <li> <p>Calculate its distance from \(w_j\).</p> </li> <li> <p>If the distance is less than \(r\), then \(w_j\) is rejected.</p> </li> </ul> </li> <li> <p>If all the samples \(q_m\) were adequately far from \(w_j\), then \(w_j\) is approved, and is added to \(S\), \(A\) and \(G\).</p> </li> </ul> </li> <li> <p>If all the candidates \(w_j\) were rejected, then remove \(a_i\) from \(A\).</p> </li> </ul> </li> </ol> <blockquote> Each cell in the grid \(G\) has \(3^n - 1\) <b>distinct</b> neighbors. <br/> <br/> <b><b>Proof</b></b> <br/> <br/> Let \(C\) be a cell in \(G\) with index \(i\), such that $$ i = (i_1, i_2, ......, i_n) $$ A cell with index \(j\) is a neighbor to \(C\) if and only if $$ \forall_{1 \, \leq \, k \, \leq \, n} \; \; j_k = i_k ± d $$ where \(d \in \{ -1, 0, 1\} \). That is, <br/> <br/> <ul><li> If \(d = -1\), then we get the previous cell in dimension \(k\)</li></ul> <ul><li> If \(d = 0\), then we get the same cell in dimension \(k\)</li></ul> <ul><li> If \(d = 1\), then we get the next cell in dimension \(k\)</li></ul> <br/> This means that for every dimension \(1 \, \leq \, k \, \leq \, n\), there are \(3\) neighboring cells. Hence, the total number of neighbors to \(C\) is $$ 3 \times 3 \times ... \times 3 = 3^n $$ However, this count includes the cell \(C\) itself, which is the case when \(d = 0\) in all \(k\) dimensions. Thus, the total number of <b>distinct</b> neighbors is $$ 3^n - 1 $$ \(\blacksquare\) </blockquote> <p><br/></p> <p>Let \(C\) be a cell in \(G\) with index \(i = (i_1, i_2, ......, i_n)\). We know that \(C\) has \(3^n\) neighbors \(\{N_1, N_2, ..., N_{3^n -1}\}\), including \(C\) itself. We can calculate the cell index of \(N_j\) using the following function:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">ComputeNeighborCellIndex</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">j</span> <span class="o">/=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The idea of this function is that we represent each index \(j\), where \(1 \leq j \leq 3^n\) as a base-3 number (Ternary). Then using this ternary representation, we extract the offset \(d\) by subtracing \(1\) from every digit. This offset will be added to the index of cell \(C\) to calculate the index of the neighbouring cell. That is,</p> <p><br/></p> <table> <thead> <tr> <th>Decimal</th> <th>Ternary</th> <th>Offset</th> </tr> </thead> <tbody> <tr> <td>\(0\)</td> <td>\(000\)</td> <td>\(\{-1, -1, -1\}\)</td> </tr> <tr> <td>\(1\)</td> <td>\(001\)</td> <td>\(\{-1, -1, 0\}\)</td> </tr> <tr> <td>\(2\)</td> <td>\(002\)</td> <td>\(\{-1, -1, 1\}\)</td> </tr> <tr> <td>\(3\)</td> <td>\(010\)</td> <td>\(\{-1, 0, -1\}\)</td> </tr> <tr> <td>\(4\)</td> <td>\(011\)</td> <td>\(\{-1, 0, 0\}\)</td> </tr> <tr> <td>\(5\)</td> <td>\(012\)</td> <td>\(\{-1, 0, 1\}\)</td> </tr> <tr> <td>\(6\)</td> <td>\(020\)</td> <td>\(\{-1, 1, -1\}\)</td> </tr> <tr> <td>\(7\)</td> <td>\(021\)</td> <td>\(\{-1, 1, 0\}\)</td> </tr> <tr> <td>\(8\)</td> <td>\(022\)</td> <td>\(\{-1, 1, 1\}\)</td> </tr> <tr> <td>\(9\)</td> <td>\(100\)</td> <td>\(\{0, -1, -1\}\)</td> </tr> <tr> <td>\(10\)</td> <td>\(101\)</td> <td>\(\{0, -1, 0\}\)</td> </tr> </tbody> </table> <p><br/></p> <blockquote> The size of each cell in the grid \(G\) must be at most \(\frac{r}{\sqrt(n)}\). <br/> <br/> <b><b>Proof</b></b> <br/> <br/> We know that the distance between any two points must be at least \(r\). We also know that each cell in the grid \(G\) must have only one point. Consider the cell \(C\) in \(G\). Let \(d\) be the length of the diagonal of \(C\) and \(s\) be its cell size. Suppose for the sake of contradiction that \(d &gt; r\). This means that two points can be placed inside \(C\) whose distance is greater than or equal to \(r\). This violates the requirement that each cell in the grid \(G\) must have only one point. Thus, \(d \leq r\). <div class="row align-items-center mt-3"> <div class="col-md-10"> <br/> <br/> Now, using Pythagoras theorem: $$ d^2 = s_1^2 + s_2^2 + ...... + s_n^2 = n \; s^2 $$ $$ s^2 = \frac{d^2}{n} $$ $$ s = \sqrt(\frac{d^2}{n}) = \frac{d}{\sqrt(n)} $$ Since \(d \leq r\), then $$ s \leq \frac{r}{\sqrt(n)} $$ </div> <div class="col-md-2"> <figure class="col-md-6 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PoissonDiskSampling/Dark/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PoissonDiskSampling/Dark/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PoissonDiskSampling/Dark/1-1400.webp"/> <img src="/assets/img/Blog/PoissonDiskSampling/Dark/1.png" width="300" height="300" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-6 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PoissonDiskSampling/Light/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PoissonDiskSampling/Light/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PoissonDiskSampling/Light/1-1400.webp"/> <img src="/assets/img/Blog/PoissonDiskSampling/Light/1.png" width="300" height="300" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> \(\blacksquare\) </blockquote> <p><br/></p> <p><strong>Bridson’s</strong> algorithm is much faster than the <strong>dart-throwing</strong> algorithm. The number of iterations of the loop in Step \(5\) is exactly \(2N-1\), where \(N\) is the number of samples. Each iteration takes \(O(k)\) time. This means that the time complexity \(T(N)\) of the algorithm is</p> \[T(N) = k(2N-1) = 2kN - k = O(2kN) - O(k) = O(kN)\] <p>Since \(k\) is constant, then \(T(N) = O(N)\) time. That is, the algorithm is <strong>linear</strong>.</p> <blockquote> Step \(5\) is executed exaclty \(2N-1\) times. <br/> <br/> <b><b>Proof</b></b> <br/> <br/> The loop in step \(5\) of the algorithm terminates only if the active set \(A\) is empty. For each iteration of the loop, exactly <b>one</b> of the following <b>two</b> events occur: <br/> <br/> <ul><li> A new sample is added to \(A\)</li></ul> <ul><li> An existing active sample is removed from \(A\)</li></ul> <br/> Each sample point \(s_i \in S\) must <b>once</b> be added to \(A\) and <b>once</b> be removed from \(A\). After it is removal from \(A\), it can never be readded back into \(A\). This means that the total number of insertions is \(N\) and the total number of removals is \(N\). Since only one event happens in each iteration of the loop, then the number of iterations of the loop is \(2N\). However, the insertion of the first sample \(x\) into \(A\) is done in step \(4\) before the loop. Thus, the total number of iterations of the loop in step \(5\) is exactly \(2N-1\). <br/> <br/> \(\blacksquare\) <br/> </blockquote> <p><br/></p> <p>Below is a full C++ implementation of <strong>Bridson’s</strong> algorithm:</p> <p><br/></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp">
</span>


<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">D</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">PoissonDisk</span><span class="p">{</span>
    
<span class="nl">private:</span>
    
    <span class="k">static</span> <span class="kt">float</span> <span class="n">Length</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">length</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="kt">float</span> <span class="nf">Random</span><span class="p">(</span><span class="kt">float</span> <span class="n">min</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">rng</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="p">{}());</span>
        <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="nf">dist</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Random</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Normalize</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        
        <span class="kt">float</span> <span class="n">length</span> <span class="o">=</span> <span class="n">Length</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mf">0.0f</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">length</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">RandomWithinSphericalAnnulus</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">sample</span><span class="p">,</span> <span class="kt">float</span> <span class="n">minDistance</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">minDir</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">minDir</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">;</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">maxDir</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">maxDir</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">randomDir</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">Random</span><span class="p">(</span><span class="n">minDir</span><span class="p">,</span> <span class="n">maxDir</span><span class="p">));</span>
        
        <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="n">minDistance</span><span class="p">,</span> <span class="mf">2.0f</span> <span class="o">*</span> <span class="n">minDistance</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">newSample</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">newSample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">randomDir</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">newSample</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">Subtract</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">ComputeGridIndex</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">sample</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cellSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">gridIndex</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">gridIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">cellSize</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">gridIndex</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">ComputeNeighborGridIndex</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rank</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">rank</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">neighborIndex</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">){</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">tmp</span> <span class="o">/=</span> <span class="mi">3</span><span class="p">;</span>
            <span class="n">neighborIndex</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">neighborIndex</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">ComputeFlattenedGridIndex</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">gridIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">gridResolutions</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">flattenedGridIndex</span> <span class="o">=</span> <span class="n">gridIndex</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">gridResolutions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">flattenedGridIndex</span> <span class="o">+=</span> <span class="p">(</span><span class="n">gridIndex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">stride</span><span class="p">);</span>
            <span class="n">stride</span> <span class="o">*=</span> <span class="n">gridResolutions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">flattenedGridIndex</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">ComputeGridResolutions</span><span class="p">(</span><span class="kt">float</span> <span class="n">cellSize</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">gridResolutions</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">gridResolutions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">((</span><span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">cellSize</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">gridResolutions</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">ComputeTotalNumGridCells</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">gridResolutions</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">totalNumGridCells</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">totalNumGridCells</span> <span class="o">*=</span> <span class="n">gridResolutions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">return</span> <span class="n">totalNumGridCells</span><span class="p">;</span>
    <span class="p">}</span>
        
<span class="k">public</span><span class="o">:</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&gt;</span> <span class="n">Generate</span><span class="p">(</span><span class="kt">int</span> <span class="n">numSamples</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxNumAttempts</span><span class="p">,</span> <span class="kt">float</span> <span class="n">minDistance</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&amp;</span> <span class="n">max</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">numNeighbors</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">D</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">cellSize</span> <span class="o">=</span> <span class="n">minDistance</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">gridResolutions</span> <span class="o">=</span> <span class="n">ComputeGridResolutions</span><span class="p">(</span><span class="n">cellSize</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
        
        <span class="kt">int</span> <span class="n">totalNumGridCells</span> <span class="o">=</span> <span class="n">ComputeTotalNumGridCells</span><span class="p">(</span><span class="n">gridResolutions</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">initialSample</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">initialSample</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0f</span><span class="p">;</span>                
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">initialSampleGridIndex</span> <span class="o">=</span> <span class="n">ComputeGridIndex</span><span class="p">(</span><span class="n">initialSample</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">initialSampleFlattenedGridIndex</span> <span class="o">=</span> <span class="n">ComputeFlattenedGridIndex</span><span class="p">(</span><span class="n">initialSampleGridIndex</span><span class="p">,</span> <span class="n">gridResolutions</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;&gt;</span> <span class="n">samples</span><span class="p">;</span>
        <span class="n">samples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">initialSample</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">activeSamples</span><span class="p">;</span>
        <span class="n">activeSamples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">totalNumGridCells</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">initialSampleFlattenedGridIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">activeSamples</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">numSamples</span><span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">activeSamples</span><span class="p">[</span><span class="n">activeSamples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">]];</span>
            
            <span class="kt">bool</span> <span class="n">retire</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxNumAttempts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">RandomWithinSphericalAnnulus</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">minDistance</span><span class="p">);</span>
                                
                <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">candidateGridIndex</span> <span class="o">=</span> <span class="n">ComputeGridIndex</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">candidateFlattenedGridIndex</span> <span class="o">=</span> <span class="n">ComputeFlattenedGridIndex</span><span class="p">(</span><span class="n">candidateGridIndex</span><span class="p">,</span> <span class="n">gridResolutions</span><span class="p">);</span>
                
                <span class="kt">bool</span> <span class="n">candidateApproved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">numNeighbors</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">){</span>
                    
                    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">neighborGridIndex</span> <span class="o">=</span> <span class="n">ComputeNeighborGridIndex</span><span class="p">(</span><span class="n">candidateGridIndex</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
                    
                    <span class="k">if</span><span class="p">(</span><span class="n">neighborGridIndex</span> <span class="o">==</span> <span class="n">candidateGridIndex</span><span class="p">)</span>
                        <span class="k">continue</span><span class="p">;</span>
                    
                    <span class="kt">int</span> <span class="n">neighborFlattenedGridIndex</span> <span class="o">=</span> <span class="n">ComputeFlattenedGridIndex</span><span class="p">(</span><span class="n">neighborGridIndex</span><span class="p">,</span> <span class="n">gridResolutions</span><span class="p">);</span>
                                        
                    <span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">neighborFlattenedGridIndex</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">continue</span><span class="p">;</span>
                    
                    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">neighborFlattenedGridIndex</span><span class="p">]];</span>
                    
                    <span class="k">if</span><span class="p">(</span><span class="n">Length</span><span class="p">(</span><span class="n">Subtract</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">candidate</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">minDistance</span><span class="p">){</span>
                        <span class="n">candidateApproved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                
                <span class="k">if</span><span class="p">(</span><span class="n">candidateApproved</span><span class="p">){</span>
                    <span class="n">samples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">candidate</span><span class="p">);</span>
                    <span class="n">activeSamples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">candidateFlattenedGridIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">retire</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">retire</span><span class="p">)</span>
                <span class="n">activeSamples</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">samples</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p><br/></p> <hr/> <p><br/></p> <h4 id="references-"><strong>References</strong> <br/></h4> <p><br/></p> <p><strong>[1]</strong> <a href="https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf">Fast Poisson Disk Sampling in Arbitrary Dimensions by Robert Bridson</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Sampling Algorithm]]></summary></entry><entry><title type="html">Planes in 3D Space</title><link href="https://amrhmorsy.github.io/blog/2025/Planesin3DSpace/" rel="alternate" type="text/html" title="Planes in 3D Space"/><published>2025-12-27T09:00:00+00:00</published><updated>2025-12-27T09:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2025/Planesin3DSpace</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2025/Planesin3DSpace/"><![CDATA[<p><br/></p> <blockquote> <div class="row align-items-center mt-3"> <div class="col-md-8"> Let \(U\) and \(V\) be vectors. If \(U \cdot V = 0\), then \(U\) and \(V\) are perpendicular to each other. </div> <div class="col-md-4"> <figure class="col-md-6 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/1-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Dark/1.png" width="300" height="300" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-6 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/1-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Light/1.png" width="300" height="300" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> </blockquote> <p><br/></p> <h3 id="plane-equation-"><strong>Plane Equation</strong> <br/></h3> <p><br/></p> <p>Given a point \(P\) and a normal \(N = (A, B, C)\), the plane passing through the point \(P\) that is perpendicular to the normal \(N\) is defined as the set of points \(Q = (x, y, z)\), such that</p> <p><br/></p> <p>\begin{equation} N \cdot (Q-P) = 0 \end{equation}</p> <p><br/></p> <p>We can rewrite this equation as</p> \[N \cdot (Q-P) = 0\] \[(N \cdot Q) - (N \cdot P) = 0\] \[Ax + By + Cz - (N \cdot P) = 0\] \[Ax + By + Cz + D = 0\] <p>where \(D = - (N \cdot P)\).</p> <blockquote> <div class="row align-items-center mt-3"> <div class="col-md-6"> The value of \(\frac{|D|}{||N||}\) is the distance by which the plane is offset from a parallel plane that passes through the origin. <br/> <br/> <b>Proof</b> <br/> <br/> We can expand \(\ \frac{|D|}{||N||} \) as follows: $$ \frac{|D|}{||N||} = \frac{|-N \cdot P|}{||N||} = \frac{N \cdot P}{||N||} = \frac{N}{||N||} \cdot P $$ By the definition of the dot product, the value of \(\ \frac{N}{||N||} \cdot P \) represents the length of the vector \(P\) projected onto the normalized vector \(N\). <br/> <br/> Since \(||P||\) is the distance from \(P\) to the origin, then \(\frac{N}{||N||} \cdot P\) is the distance from \(P\) to the origin along the normalized normal \(N\). Also, all the points that lie on the plane have the same distance to the origin along the normal \(N\) as the point \(P\). Thus, we can conclude that \(\frac{N}{||N||} \cdot P\) is the distance from the plane to another parallel plane that passes through the origin. </div> <div> <figure class="col-md-6 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/2-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Dark/2.png" width="500" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-6 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/2-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Light/2.png" width="500" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> </blockquote> <div class="row align-items-center mt-3"> <div class="col-md-8"> If the normal \(N\) is normalized, then we can say that the equation \begin{equation} d = (N.Q) + D \end{equation} gives the signed distance \(d\) from the plane to another parallel plane that passes through \(Q\). <br/> <br/> <ul><li> If \(d = 0\), then \(Q\) lies on the plane. </li></ul> <br/> <ul><li> If \(d &gt; 0\), then \(Q\) lies on the positive side of the plane --- the side in which the normal points. </li></ul> <br/> <ul><li> If \(d &lt; 0\), then \(Q\) lies on the negative side of the plane --- the side opposite in which the normal points. </li></ul> </div> <div> <figure class="col-md-4 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/3-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Dark/3.png" width="450" height="450" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-4 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/3-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Light/3.png" width="450" height="450" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Plane</span><span class="p">{</span>
    <span class="kt">float</span> <span class="n">D</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">N</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">float</span> <span class="nf">ComputeOffsetFromPlane</span><span class="p">(</span><span class="n">Plane</span> <span class="n">P</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">Q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">.</span><span class="n">D</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <div class="row align-items-center mt-3"> <div class="col-md-12"> We can also derive the equation of a plane if only given three points \(P\), \(Q\), and \(R\) on the plane. Using these points, we can form two vectors \(PQ\) and \(PR\) as follows: $$ \vec{PQ} = Q - P $$ $$ \vec{PR} = R - P $$ The normal of the plane can be calculated by taking the cross product of \(PQ\) and \(PR\) as follows: $$ N = \vec{PQ} \times \vec{PR} $$ The plane equation can be constructed using the derived normal \(N\) and any one of the points \(P\), \(Q\) or \(R\). </div> </div> </blockquote> <p><br/></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Plane</span><span class="p">{</span>
    <span class="kt">float</span> <span class="n">D</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">N</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Plane</span> <span class="nf">ComputePlane</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">P</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">Q</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">R</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">PQ</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">-</span> <span class="n">P</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">PR</span> <span class="o">=</span> <span class="n">R</span> <span class="o">-</span> <span class="n">P</span><span class="p">;</span>
    
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="n">PQ</span><span class="p">,</span> <span class="n">PR</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">D</span> <span class="o">=</span> <span class="o">-</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">P</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Plane</span><span class="p">{</span>
        <span class="p">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span> 
        <span class="p">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">D</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <p>It is sometimes convenient to represent a plane using 4D vectors. We can use the shorthand notation of \(L = (N, D)\). If we treat the 3D points as 4D homogenous points with \(w = 1\), then the plane equation can be re-written as</p> <p>\begin{equation} d = L \cdot Q \end{equation}</p> <p><br/></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">ComputeOffsetFromPlane</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">p</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">Q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Q</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h3 id="intersection-of-a-line-and-a-plane"><strong>Intersection of a Line and a Plane</strong></h3> <p><br/></p> <p>We know that the equation \(P(t) = S + tV\) represents a line containing the point \(S\) and running in a direction parallel to the direction \(V\). We can find the point of intersection between a line and a plane by substituting \(P(t)\) into the plane equation and solving for \(t\).</p> \[N \cdot P(t) + D = 0\] \[N \cdot (S + tV) + D = 0\] \[(N \cdot S) + (N \cdot V)t + D = 0\] <p>\begin{equation} t = \frac{- (N \cdot S) - D}{(N \cdot V)} \end{equation}</p> <p>Plugging the value of \(t\) back into the line equation gives us the point of intersection.</p> \[P(t) = S + tV\] \[P(t) = S + \frac{- (N \cdot S) - D}{(N \cdot V)} V\] <blockquote> <p>If \(N \cdot V = 0\), then \(V\) is perpendicular to \(N\). This means that the line is parallel to the plane. In that case, if \(N \cdot S + D = 0\), then the line lies on the plane. Otherwise, there is no point of intersection between them.</p> </blockquote> <p>If the plane is represented in 4D, then we can rewrite equation 4 as follows:</p> \[L \cdot P(t) = 0\] \[L \cdot (S + tV) = 0\] \[(L \cdot S) + (L \cdot V)t = 0\] \[t = \frac{-(L \cdot S)}{L \cdot V}\] <p><br/></p> <h3 id="intersection-of-a-ray-and-a-plane-"><strong>Intersection of a Ray and a Plane</strong> <br/></h3> <p><br/></p> <p>Checking for ray-plane intersection is identical to the line-plane intersection we discussed earlier. This is because a ray is the same as a line, except that a ray has one starting point and extends infinitely in one direction, while a line has no starting point and extends infinitely in both direction.</p> <p>The equation \(P(t) = P_0 + tV\) represents a ray with a starting point \(P_0\) and running in a direction parallel to \(V\). We can find the point of intersection between the ray and a plane by substituting \(P(t)\) into the plane equation and finding the value of \(t\):</p> \[N \cdot P(t) + D = 0\] \[N \cdot (P_0 + tV) + D = 0\] \[t = \frac{- (N \cdot P_0) - D}{(N \cdot V)}\] <p>If \(t &gt; 0\), then the ray intersects the plane. Otherwise, there is no intersection.</p> <p>To find the point of intersection, we simply plug the value of \(t\) back into the equation of the ray.</p> <blockquote> <p>Similar to the line-plane intersection, \(V\) is perpendicular to \(N\) if \(N \cdot V = 0\). This means that the ray is running parallel to the plane. In that case, if \(N \cdot P_0 + D = 0\), then the ray lies on the plane. Otherwise, there is no point of intersection between them.</p> </blockquote> <p><br/></p> <h3 id="intersection-of-three-planes-"><strong>Intersection of Three Planes</strong> <br/></h3> <p><br/></p> <p>Let \(L_1 = (N_1, D_1)\), \(L_2 = (N_2, D_2)\), and \(L_3 = (N_3, D_3)\) be 3 arbitrary planes. We want to find the point \(Q\) at which all 3 planes intersect. This can be done by solving for \(Q\) such that;</p> \[L_1 \cdot Q = 0\] \[L_2 \cdot Q = 0\] \[L_3 \cdot Q = 0\] <p>We can rewrite this in matrix form as</p> \[MQ = \begin{bmatrix} -D_1 \\\\ -D_2 \\\\ -D_3 \\\\ \end{bmatrix}\] <p>where \(M = \begin{bmatrix} N_{1x} &amp; N_{1y} &amp; N_{1z} \\\\ N_{2x} &amp; N_{2y} &amp; N_{2z} \\\\ N_{3x} &amp; N_{3y} &amp; N_{3z} \\\\ \end{bmatrix}\). We can then solve for \(Q\) by solving the following equation</p> \[Q = M^{-1} \begin{bmatrix} -D_1 \\\\ -D_2 \\\\ -D_3 \\\\ \end{bmatrix}\] <blockquote> <p>If \(M\) is singular, i.e., \(det(M) = 0\), then \(M\) cannot be inverted and hence, the three planes do not intersect at a point.</p> </blockquote> <p><br/></p> <h3 id="intersection-of-two-planes-"><strong>Intersection of Two Planes</strong> <br/></h3> <p><br/></p> <p>Let \(L_1 = (N_1, D_1)\) and \(L_2 = (N_2, D_2)\) be any two arbitrary planes. When \(L_1\) and \(L_2\) intersect, they form a line. Suppose the equation of that line is \(P(t) = Q + Vt\). The vector \(V\) is simply the vector perpendicular to the normals of both planes:</p> \[V = N_1 \times N_2\] <p>However, to find \(Q\), we need to construct a new plane \(H = (V, 0)\) that passes through the origin with normal \(V\), and find the point of intersection of all 3 planes \(L_1\), \(L_2\), and \(H\). That is,</p> \[Q = \begin{bmatrix} N_{1x} &amp; N_{1y} &amp; N_{1z} \\\\ N_{2x} &amp; N_{2y} &amp; N_{2z} \\\\ V_{x} &amp; V_{y} &amp; V_{z} \\\\ \end{bmatrix} ^{-1} \begin{bmatrix} -D_1 \\\\ -D_2 \\\\ 0 \\\\ \end{bmatrix}\] <p><br/></p> <h3 id="intersection-of-a-sphere-and-a-plane-"><strong>Intersection of a Sphere and a Plane</strong> <br/></h3> <p><br/></p> <p>Consider the sphere \(S\) with equation</p> \[(x-C_x)^2 + (y-C_y)^2 + (z-C_z)^2 = R^2\] <p>where \(C = (C_x, C_y, C_z)\) is the center, and \(R\) is the radius of the sphere.</p> <p><br/></p> <p>We want to test for intersection between the sphere \(S\) and an arbitrary plane \(P\). We can do that by calculating the signed distance \(d\) between the plane and the sphere center \(C\), and compare it with the radius \(R\) of the sphere:</p> \[d = (N \cdot S) + D\] <div class="row align-items-center mt-3"> <div class="col-md-8"> <ul><li> If \(-R \leq d \leq R\), then there is intersection between the sphere and the plane: </li></ul> <br/> <ul><ul> <ul><li> If \( 0 \leq d \leq R\), then sphere is on the positive side of the plane -- the side of the plane to where the normal points. </li> </ul></ul></ul> <ul><ul><ul> <li> If \( -R \leq d \leq 0\), then sphere is on the negative side of the plane -- the side of the plane opposite to where the normal points. </li> </ul> </ul> </ul> <br/> <ul><li> If \(d &lt; -R\), then there is <b>no</b> intersection between the sphere and the plane.</li> </ul> <br/> <ul><li> If \(d &gt; R\), then there is <b>no</b> intersection between the sphere and the plane.</li> </ul> </div> <div> <figure class="col-md-4 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/4-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Dark/4.png" width="450" height="450" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-4 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/4-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Light/4.png" width="450" height="450" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#define OUTSIDE_NEGATIVE -1
#define INTERSECTING 0
#define OUTSIDE_POSITIVE -1
</span>
<span class="k">struct</span> <span class="nc">Sphere</span><span class="p">{</span>
    <span class="kt">float</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">center</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">TestSpherePlaneIntersection</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">plane</span><span class="p">,</span> <span class="n">Sphere</span> <span class="n">sphere</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">sphere</span><span class="p">.</span><span class="n">center</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">sphere</span><span class="p">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OUTSIDE_NEGATIVE</span><span class="p">;</span> <span class="c1">// No Intersection -- Sphere is entirely on the negative side of the plane </span>
            
    <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">sphere</span><span class="p">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OUTSIDE_POSITIVE</span><span class="p">;</span> <span class="c1">// No Intersection -- Sphere is entirely on the positive side of the plane</span>
    
    <span class="k">return</span> <span class="n">INTERSECTING</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <p><br/></p> <h3 id="intersection-of-a-box-and-a-plane-"><strong>Intersection of a Box and a Plane</strong> <br/></h3> <p><br/></p> <p><br/></p> <h4 id="intersection-of-an-axis-aligned-box-and-a-plane-"><strong>Intersection of an Axis-Aligned Box and a Plane</strong> <br/></h4> <p><br/></p> <p>Consider an axis-aligned box \(G\), with minimum vertex \(V_{min}\) and maximum vertex \(V_{max}\). We want to test for intersection between the box \(G\) and an arbitrary plane \(P = (N, D)\), where the \(N\) is normalized. We can do that by calculating the signed distance \(d\) from the center \(C\), along the normal \(N\), to the plane \(P\), and compare it with the maximum radius \(R\), projected onto the normal \(N\), inside the box.</p> <p>The maximum radius \(R\) inside the box is given by</p> \[R = \frac {V_{max} - V{min}}{2}\] <p>This is equivalent to using the equation</p> \[R = V_{max} - C\] <p>The center \(C\) of the box is given by</p> \[C = \frac {V_{max} + V{min}}{2}\] <p>We calculate the signed distance \(d\) along the normal \(N\) from the center \(C\) to the plane using equation 2:</p> \[d = (N \cdot C) + D\] <div class="row align-items-center mt-3"> <div class="col-md-8"> We will compare \(R\) and \(d\): <br/> <br/> <br/> <ul><li> If \(d &gt; R\), then there is no intersection -- the box is completely on the positive side of the plane. </li></ul> <br/> <ul><li> If \(d &lt; -R\), then there is no intersection -- the box is completely on the negative side of the plane. </li></ul> <br/> <ul><li> If \(-R \leq d \leq R\), then there is an intersection. </li></ul> </div> <div> <figure class="col-md-5 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/5-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/5-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Dark/5-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Dark/5.png" width="450" height="450" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-5 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/5-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/5-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/PlanesIn3DSpace/Light/5-1400.webp"/> <img src="/assets/img/Blog/PlanesIn3DSpace/Light/5.png" width="450" height="450" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#define OUTSIDE_NEGATIVE -1
#define INTERSECTING 0
#define OUTSIDE_POSITIVE -1
</span>
<span class="k">struct</span> <span class="nc">AABB</span><span class="p">{</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">min</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">max</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">TestAABBPlaneIntersection</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">plane</span><span class="p">,</span> <span class="n">AABB</span> <span class="n">box</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">min</span> <span class="o">+</span> <span class="n">box</span><span class="p">.</span><span class="n">max</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5f</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">max</span> <span class="o">-</span> <span class="n">box</span><span class="p">.</span><span class="n">min</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5f</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">plane</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">plane</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">plane</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
        
    <span class="kt">float</span> <span class="n">R</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">N</span><span class="p">.</span><span class="n">x</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">N</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">N</span><span class="p">.</span><span class="n">z</span><span class="p">)));</span>
    <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OUTSIDE_POSITIVE</span><span class="p">;</span> <span class="c1">// No intersection -- Box is completely on the positive side of the plane.</span>
        
    <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">R</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OUTSIDE_NEGATIVE</span><span class="p">;</span> <span class="c1">// No intersection -- Box is completely on the negative side of the plane.</span>
    
    <span class="k">return</span> <span class="n">INTERSECTING</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="intersection-of-an-object-oriented-box-and-a-plane-"><strong>Intersection of an Object-Oriented Box and a Plane</strong> <br/></h4> <p><br/></p> <p>Consider an object-oriented box \(G\), with center \(C\), local coordinate axes \(u_0\), \(u_1\), and \(u_2\), and three scalars \(e_0\), \(e_1\), and \(e_2\). The points \(R\) in \(G\) are given by</p> \[R = C ± a_0 u_0 ± a_1 u_1 ± a_2 u_2\] <p>where \(a_i \leq e_i\). Similarly, the eight corner vertices \(V_i\) of the box are given by</p> \[V_i = C ± e_0 u_0 ± e_1 u_1 ± e_2 u_2\] <p><br/></p> <p>We want to test for intersection between the box \(G\) and an arbitrary plane \(P = (N, D)\), where the \(N\) is normalized. We can do that by calculating the signed distance \(d\) from the center \(C\), along the normal \(N\), to the plane \(P\), and compare it with the maximum radius \(R\), projected onto the normal \(N\), inside the box.</p> <p>The corner vertices \(V_i\) of the box are considered the points inside the box that are the furthest away from the center \(C\). Hence, we will only consider them when calculating the maximum radius \(R\). The radii \(r_i\) projected onto the normal \(N\) of each vertex \(V_i\) is given by</p> \[r_i = (V_i - C) \cdot n = (C ± e_0 u_0 ± e_1 u_1 ± e_2 u_2 - C) \cdot n\] \[r_i = (e_0 u_0 ± e_1 u_1 ± e_2 u_2) \cdot n\] \[r_i = (e_0 u_0 \cdot n) ± (e_1 u_1 \cdot n) ± (e_2 u_2 \cdot n)\] <p>The maximum radius \(R\) is obtained when all the involved terms are positive, which is achieved by taking the absolute values of all the terms. That is,</p> \[R = |(e_0 u_0 \cdot n)| + |(e_1 u_1 \cdot n)| + |(e_2 u_2 \cdot n)|\] <p>Since the extents \(e_0\), \(e_1\), and \(e_2\) are assumed to be positive, then</p> \[R = e_0|(u_0 \cdot n)| + e_1|(u_1 \cdot n)| + e_2|(u_2 \cdot n)|\] <blockquote> <p>If \(N\) is not normalized, then \(R = \frac {e_0|(u_0 \cdot n)| + e_1|(u_1 \cdot n)| + e_2|(u_2 \cdot n)|}{||N||}\)</p> </blockquote> <p>Finally, we calculate the signed distance \(d\) along the normal \(N\) from the center \(C\) to the plane using equation 2:</p> \[d = (N \cdot C) + D\] <p>We will compare \(R\) and \(d\):</p> <ul> <li> <p>If \(d &gt; R\), then there is no intersection – the box is completely on the positive side of the plane.</p> </li> <li> <p>If \(d &lt; -R\), then there is no intersection – the box is completely on the negative side of the plane.</p> </li> <li> <p>If \(-R \leq d \leq R\), then there is an intersection.</p> </li> </ul> <p><br/></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#define OUTSIDE_NEGATIVE -1
#define INTERSECTING 0
#define OUTSIDE_POSITIVE -1
</span>
<span class="k">struct</span> <span class="nc">OOB</span><span class="p">{</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">center</span><span class="p">;</span>    
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">TestOOBPlaneIntersection</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">plane</span><span class="p">,</span> <span class="n">OOB</span> <span class="n">box</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">n</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="n">plane</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">plane</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">plane</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
    
    <span class="kt">float</span> <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">)))</span> <span class="o">+</span> <span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">)))</span> <span class="o">+</span> <span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">n</span><span class="p">)));</span>
        
    <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">center</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">));</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OUTSIDE_POSITIVE</span><span class="p">;</span> <span class="c1">// No intersection -- Box is completely on the positive side of the plane.</span>
        
    <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">R</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OUTSIDE_NEGATIVE</span><span class="p">;</span> <span class="c1">// No intersection -- Box is completely on the negative side of the plane.</span>
    
    <span class="k">return</span> <span class="n">INTERSECTING</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/> <br/></p> <hr/> <p><br/></p> <h4 id="references-"><strong>References</strong> <br/></h4> <p><br/></p> <p><strong>[1]</strong> 3D Math Primer for Graphics and Game Development by Fletcher Dunn and Ian Parbery</p> <p><strong>[2]</strong> Mathematics for 3D Game Programming and Computer Graphics by Eric Lengyel</p> <p><strong>[3]</strong> Real-time Collision Detection by Christer Ericson</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Planes in 3D Space]]></summary></entry><entry><title type="html">Understanding Barycentric Coordinates</title><link href="https://amrhmorsy.github.io/blog/2025/BarycentricCoordinates/" rel="alternate" type="text/html" title="Understanding Barycentric Coordinates"/><published>2025-02-09T12:00:00+00:00</published><updated>2025-02-09T12:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2025/BarycentricCoordinates</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2025/BarycentricCoordinates/"><![CDATA[<div class="row align-items-center mt-3"> <div class="col-md-6"> <h3><b><b> Introduction </b></b></h3> <br/> <br/> A <b><b>nondegenerate</b></b> triangle is a triangle where: <br/> <br/> <li> All vertices are distinct</li> <li> The vertices do not all lie on a single line (Non-collinear vertices)</li> <br/> Consider the following <b>nondegenerate</b> triangle with vertices \(A\), \(B\), and \(C\). </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/1-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/1.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/1-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/1.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <p><br/></p> <div class="row align-items-center mt-3"> <div class="col-md-4"> A point \(Q\) that lies on the edge \(AB\) has the form $$ Q = (1-t)A + tB $$ where \(0 \leq t \leq 1\). </div> <div class="col-md-8"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/2-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/2.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/2-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/2.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <div class="row align-items-center mt-3"> <div class="col-md-4"> Similarly, a point \(R\) that lies on the edge \(QC\) has the form $$ R = (1-s)Q + sC $$ where \(0 \leq s \leq 1\). </div> <div class="col-md-8"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/3-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/3.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/3-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/3.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <p>We can rewrite \(R\) by substituting the equation for \(Q\). This results in the following equation</p> \[R = (1-s)((1-t)A + tB) + sC\] \[R = (1-s)(1-t)A + (1-s)tB + sC\] <p>Now, if we sum the coefficients of equation of \(R\), we get</p> \[(1-s)(1-t) + (1-s)t + s = (1 - t - s + st) + (t - st) + s = 1\] <p>Since \(R\) is an arbitrary point inside the triangle \(ABC\), we can generalize the equation to any point \(P\).</p> <p>That is, any point \(P\) inside the triangle \(ABC\) has the form</p> \[P = αA + βB + γC\] <p>where \(α + β + γ = 1\) and \(α, β, γ \geq 0\).</p> <div class="row align-items-center mt-3"> <div class="col-md-6"> These coefficients \(α\), \(β\) and \(γ\) are called the <b>barycentric coordinates</b> of \(P\) with respect to the triangle \(ABC\), such that <br/> <br/> <li> If \(α = 0\), then \(P\) lies on the edge \(BC\)</li> <li> If \(β = 0\), then \(P\) lies on the edge \(AC\)</li> <li> If \(γ = 0\), then \(P\) lies on the edge \(AB\)</li> </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/4-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/4.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/4-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/4.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <p><br/></p> <h3 id="calculating-barycentric-coordinates-"><strong>Calculating Barycentric Coordinates</strong> <br/></h3> <p><br/></p> <div class="row align-items-center mt-3"> <div class="col-md-6"> The equations for calculating the <b>barycentric coordinates</b> are $$ α = \frac{Area(▲PBC)}{Area(▲ABC)} $$ $$ β = \frac{Area(▲PAC)}{Area(▲ABC)} $$ $$ γ = \frac{Area(▲PAB)}{Area(▲ABC)} $$ <br/> The proof for these equations will be explained later in this blog post. </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/5-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/5-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/5-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/5.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/5-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/5-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/5-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/5.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <p><br/></p> <h3 id="calculating-area-of-the-triangle-"><strong>Calculating Area of the Triangle</strong> <br/></h3> <p><br/></p> <p>There are 2 ways to calculate the area of the triangle:</p> <div class="row align-items-center mt-3"> <div class="col-md-6"> <b><b>Approach 1</b></b> <br/> <br/> The area of the triangle is $$ Area = \frac{1}{2} \times Base \times Height $$ where \(Height\) is the perpendicular shortest distance from the the base edge to the opposite vertex. For example, the area of triangle \(PBC\) is $$ Area(▲PBC) = \frac{1}{2} \times ||\vec{BC}|| \times d_{⊥} (P,BC) $$ </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/6-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/6-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/6-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/6.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/6-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/6-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/6-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/6.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <div class="row align-items-center mt-3"> <div class="col-md-6"> <b><b>Approach 2</b></b> <br/> <br/> Another easier way to calculate the area of the triangle, is to use the area of the parallelogram. Consider the parallelogram \(ABCD\). The area of the parallelogram \(ABCD\) is $$ Area(▰ABCD) = ||\vec{AB}|| \times ||\vec{AC}|| \times sin(\theta) $$ We can also express the area of the parallelogram \(ABCD\) as the magnitude of the cross product of two vectors that lie on the parallelogram. That is, $$ Area(▰ABCD) = ||\vec{AB} \times \vec{AC}|| $$ The area of the triangle is equal to half the area of the parallelogram. Hence, the area of the triangle \(ABC\) can be expressed as $$ Area(▲ABC) = \frac{||\vec{AB}|| \times ||\vec{AC}|| \times sin(\theta)}{2} = \frac{||\vec{AB} \times \vec{AC}|| }{2} $$ </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/7-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/7-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/7-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/7.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/7-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/7-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/7-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/7.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <div class="row align-items-center mt-3"> <div class="col-md-6"> <h3><b><b>Proof</b></b></h3> <br/> <br/> Consider the triangle \(ABC\). Let \(P\) be a point inside the triangle. We know that $$ P = αA + βB + γC $$ where \(α + β + γ = 1\) and \(α, β, γ \geq 0\). </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/8-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/8-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/8-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/8.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/8-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/8-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/8-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/8.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <div class="row align-items-center mt-3"> <div class="col-md-6"> We want to prove that $$ α = \frac{Area(▲PBC)}{Area(▲ABC)} $$ $$ β = \frac{Area(▲PAC)}{Area(▲ABC)} $$ $$ γ = \frac{Area(▲PAB)}{Area(▲ABC)} $$ Without loss of generality, consider the barycentric coordinate \(α\). Let \(d_P\) be the perpendicular distance from \(P\) to \(BC\) and \(d_A\) be the perpendicular distance from \(A\) to \(BC\). </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/9-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/9-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/9-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/9.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/9-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/9-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/9-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/9.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <div class="row align-items-center mt-3"> <div class="col-md-6"> We know that the area of triangle \(PBC\) is $$ Area(▲PBC) = \frac{1}{2} \times ||\vec{BC}|| \times d_P $$ and the area of triangle \(ABC\) is $$ Area(▲ABC) = \frac{1}{2} \times ||\vec{BC}|| \times d_A $$ From these equations, we can see that - \(Area(▲PBC)\) is linearly proportional to the perpendicular distance from \(P\) to \(BC\) ; \(d_P\) $$ Area(▲PBC) ∝ d_P $$ - \(Area(▲ABC)\) is linearly proportional to the perpendicular distance from \(A\) to \(BC\) ; \(d_A\). $$ Area(▲ABC) ∝ d_A $$ As \(d_P\) decreases, the point \(P\) becomes closer to the edge \(BC\), causing the value of \(α\) to also decrease. When \(d_P=0\), the point \(P\) lies on the edge \(BC\) and \(α=0\). </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/10-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/10-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/10-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/10.png" width="550" height="500" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/10-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/10-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/10-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/10.png" width="550" height="500" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <p><br/> <br/></p> <div class="row align-items-center mt-3"> <div class="col-md-6"> As \(d_P\) increases, the point \(P\) becomes closer to the point \(A\), causing the value of \(α\) to increase. When \(d_P=d_A\), the point \(P\) coincides the point \(A\) and \(α = 1\). This implies that \(α\) is proportional to \(d_P\) $$ α ∝ d_P $$ where the proportionality constant is \(d_A\). That is, $$ α = \frac{d_P}{d_A} $$ Since \(d_P\) is linearly proportional to \(Area(PBC)\) and \(d_A\) is linearly proportional to \(Area(ABC)\), then we can rewrite \(α\) as $$ α = \frac{Area(▲PBC)}{Area(▲ABC)} $$ By applying the same reasoning to the other two coordinates, we obtain that $$ β = \frac{Area(▲PAC)}{Area(▲ABC)} $$ $$ γ = \frac{Area(▲PAB)}{Area(▲ABC)} $$ Thus, proof is complete. </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/11-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/11-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/11-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/11.png" width="550" height="500" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/11-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/11-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/11-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/11.png" width="550" height="500" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <p><br/> <br/></p> <div class="row align-items-center mt-3"> <div class="col-md-6"> <h3><b><b> Applications of Barycentric Coordinates</b></b></h3> <br/> <br/> In modern <b>computer graphics</b>, triangles are the fundamental building block for rendering. <br/> <br/> All complex geometric meshes are processed in the GPU (Graphics Processing Unit) in terms of triangles. <br/> <br/> Regardless of how complex a 3D model is (e.g., spheres, characters, buildings, etc..), it is ultimately broken down into a mesh of triangles that the GPU processes. <br/> <br/> Why triangles? Because today’s <b>GPUs (Graphics Processing Units)</b> are highly optimized to handle triangle-based operations very efficiently. <br/> <br/> Because triangles are such a widely used geometric primitive, there are many applications for <b>barycentric coordinates</b>. <br/> <br/> One of the key steps in the graphics pipeline is <b>rasterization</b>. <br/> <br/> During <b>rasterization</b>, the GPU needs to determine whether a pixel is inside the triangle or outside the triangle. </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/12-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/12-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/12-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/12.png" width="700" height="500" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/12-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/12-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/12-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/12.png" width="700" height="500" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <div class="row align-items-center mt-3"> <div class="col-md-4"> If the pixel is inside the triangle, it will be shaded. If the pixel is outside the triangle, it will not be shaded. <br/> <br/> The GPU uses <b>barycentric coordinates</b> \(α\), \(β\), and \(γ\), given the pixel coordinates and the coordinates of each vertex of the triangle, to determine if the pixel is inside the triangle or outside the triangle. <br/> <br/> If \(α + β + γ = 1\) and \(α, β, γ \geq 0\), then the pixel is inside the triangle and it will be shaded. <br/> <br/> Otherwise, the pixel is outside the triangle and it will not be shaded. </div> <div class="col-md-8"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/13-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/13-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Dark/13-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Dark/13.png" width="600" height="500" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/13-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/13-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/BarycentricCoordinates/Light/13-1400.webp"/> <img src="/assets/img/Blog/BarycentricCoordinates/Light/13.png" width="600" height="500" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <p><br/></p> <hr/> <p><br/></p> <h3 id="references"><strong>References</strong></h3> <p><br/></p> <ul> <li>Chapter 7.9.1 - Computer Graphics: Principles and Practice by John F. Hughes</li> </ul> <p><br/></p> <hr/>]]></content><author><name></name></author><summary type="html"><![CDATA[Introduction A nondegenerate triangle is a triangle where: All vertices are distinct The vertices do not all lie on a single line (Non-collinear vertices) Consider the following nondegenerate triangle with vertices \(A\), \(B\), and \(C\).]]></summary></entry><entry><title type="html">Refraction Vector Calculation</title><link href="https://amrhmorsy.github.io/blog/2024/RefractionVectorCalculation/" rel="alternate" type="text/html" title="Refraction Vector Calculation"/><published>2024-10-31T12:00:00+00:00</published><updated>2024-10-31T12:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2024/RefractionVectorCalculation</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2024/RefractionVectorCalculation/"><![CDATA[<p><br/></p> <h3 id="introduction-"><strong>Introduction</strong> <br/></h3> <p><br/></p> <p>When a beam of light hits the surface of an object, part of its energy is absorbed by the surface, part of its energy is reflected away and part of its energy may refract through the object itself.</p> <p>In this post, we will explore the mathematics behind calculating the refraction vector.</p> <p><br/></p> <div class="row align-items-center mt-3"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/1-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Dark/1.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/1-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Light/1.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> <p><br/></p> <p><br/></p> <h3 id="snell-law-"><strong>Snell Law</strong> <br/></h3> <p><br/></p> <p>Transparent surfaces have a property called the <strong>index of refraction</strong>. This refractive index determines how much the path of light is bent or refracted, when entering a material. This can be explained by <strong>Snell’s Law</strong>.</p> <p>Let:</p> <ul> <li>\(n_L\) be the index of refraction of the material the light is leaving,</li> <li>\(\theta_L\) be the angle of incidence,</li> <li>\(n_T\) be the index of refraction of the material the light is entering, and</li> <li>\(\theta_T\) be the angle of refraction.</li> </ul> <p>According to Snell’s Law,</p> \[n_L sin \theta_L = n_T sin \theta_T\] <p>Each material has its own unique index of refraction. For example, the index of refraction of air is <strong>1.000293</strong>, while the index of refraction of diamond is <strong>2.417</strong>. Higher indexes of refraction create a greater bending effect at the interface between two materials, causing the refraction vector to bend more towards the normal vector.</p> <p><br/></p> <div class="row align-items-center mt-3"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/2-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Dark/2.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/2-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Light/2.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> <p><br/></p> <p>Now, let:</p> <ul> <li>\(L\) be the incoming light vector,</li> <li>\(N\) be the normal vector, and</li> <li>\(T\) be the refracted light vector.</li> </ul> <p>We assume that \(L\), \(N\) and \(T\) are normalized to unit length.</p> <p><br/></p> <h3 id="decomposition-of-incoming-light-vector-l-">Decomposition of Incoming Light Vector \(L\) <br/></h3> <p><br/></p> <p>To calculate the refraction vector \(T\), we first need to decompose the incoming light vector \(L\) in relation to the surface normal vector \(N\).</p> <p>Each vector has both a parallel component and perpendicular component relative to the normal vector \(N\).</p> <p><br/></p> <div class="row align-items-center mt-3"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/3-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Dark/3.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/3-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Light/3.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> <p><br/></p> <p>The parallel component of \(L\) along \(N\) is</p> \[L_{||N} = (N.L)N = N cos \theta_L\] <p>The perpendicular component of \(L\) along \(N\) can be calculated by subtracting \(L_{||N}\) from \(L\) . That is,</p> \[L_{⊥N} = L - L_{||N} = L - (N.L)N\] <p>Next, let’s calculate the magnitudes of \(L_{||N}\) and \(L_{⊥N}\)</p> <p>Since the vectors \(L\) , \(L_{||N}\) and \(L_{⊥N}\) form a right-angled triangle, we can use trignometric relationships to calculate their magnitudes.</p> <p>We know that</p> \[sin\theta_L = \frac{|L_{⊥N}|}{L}\] <p>and</p> \[cos\theta_L = \frac{|L_{||N}|}{L}\] <p>Since \(L\) has been normalized to unit length (i.e., \(|L| = 1\) ), then</p> \[|L_{⊥N}| = sin \theta_L\] <p>and</p> \[|L_{||N}| = cos \theta_L\] <p><br/></p> <h3 id="decomposition-of-refraction-vector-t-"><strong>Decomposition of Refraction Vector \(T\)</strong> <br/></h3> <p><br/></p> <p>Just like we did with the incoming light vector \(L\), we are going to decompose the refraction vector \(T\) in relation to the surface normal vector \(N\).</p> <p><br/></p> <div class="row align-items-center mt-3"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/4-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Dark/4.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/4-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Light/4.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> <p><br/></p> <p>The parallel component of \(T\) along \(N\) is</p> \[T_{||N} = (-N.T)(-N) = -N cos \theta_T\] <p>As we know, we can calculate the perpendicular component of \(T\) along \(N\) as:</p> \[T_{⊥N} = T - T_{||}\] <p>However, we do not know \(T\). Hence, we must find another way to calculate \(T_{⊥N}\).</p> <p>Let’s first calculate the magnitudes of \(T_{||N}\) and \(T_{⊥N}\) .</p> <p>Since the vectors \(T\) , \(T_{||N}\) and \(T_{⊥N}\) form a right-angled triangle, we can use trignometric relationships to calculate their magnitudes.</p> <p>We know that</p> \[sin\theta_T = \frac{|T_{⊥N}|}{|T|}\] <p>and</p> \[cos\theta_T = \frac{|T_{||}|}{T}\] <p>Since \(T\) is normalized to unit length(i.e., \(|T| = 1\) . Then,</p> \[|T_{⊥N}| = sin\theta_T\] <p>Now that we have \(|T_{⊥N}|\) , let’s return to the problem of calculating \(T_{⊥N}\) .</p> <p>Since \(T_{⊥N}\) has the same direction as \(L_{⊥N}\), then we can calculate \(T_⊥\) as:</p> \[T_⊥ = \frac{L_{⊥N}}{|L_{⊥N}|} |T_{⊥N}| = \frac{L_{⊥N}}{|L_{⊥N}|} sin \theta_T = \frac{L-(N.L)N}{sin \theta_L} sin \theta_T\] <p><br/></p> <h3 id="calculation-of-refraction-vector-t-"><strong>Calculation of Refraction Vector \(T\)</strong> <br/></h3> <p><br/></p> <p>Finally, we can calculate the refraction vector \(T\) by adding \(T_{||N}\) and \(T_{⊥N}\) . That is,</p> \[T = T_{||N} + T_{⊥N}\] \[T = (-N.T)(-N) + \frac{L-(N.L)N}{sin \theta_L} sin \theta_T\] \[T = -N cos \theta_T + \frac{L-(N.L)N}{sin \theta_L} sin \theta_T\] <p>Let’s do some further simplification to the equation.</p> <p>We can use <strong>Snell Law</strong> to replace \(\frac{sin\theta_T}{sin\theta_L}\) with \(\frac{n_L}{n_T}\). This yields:</p> \[T = -N cos \theta_T + \frac{n_L}{n_T}(L-(N.L)N)\] <p>We can also replace \(cos \theta_T\) with \(\sqrt{1-sin^2 \theta_T}\) , which gives us</p> \[T = -N \sqrt{1-sin^2 \theta_T} + \frac{n_L}{n_T}(L-(N.L)N)\] <p>Furthermore, we can use <strong>Snell Law</strong> to replace \(sin^2 \theta_T\) with \(\frac{n_L^2}{n_T^2} sin^2 \theta_L\) . The result is</p> \[T = -N \sqrt{1-\frac{n_L^2}{n_T^2} sin^2 \theta_L} + \frac{n_L}{n_T}(L-(N.L)N)\] <p>Finally, we can replace \(sin^2 \theta_L\) with \(1-cos^2 \theta_L = 1 - (N.L)^2\)</p> <p>This gives us:</p> \[T = -N \sqrt{1-\frac{n_L^2}{n_T^2} (1-(N.L)^2)} + \frac{n_L}{n_T}(L-(N.L)N)\] \[T = -N \sqrt{1-\frac{n_L^2}{n_T^2} (1-(N.L)^2)} + \frac{n_L}{n_T}L - \frac{n_L}{n_T}(N.L)N\] <p>\begin{equation} T = N ( - \frac{n_L}{n_T}(N.L) - \sqrt{1-\frac{n_L^2}{n_T^2} (1-(N.L)^2)} ) + \frac{n_L}{n_T}L \end{equation}</p> <p>Now, if you noticed, equation 1 contains a radical. If the quantity inside the radical is negative, the equation becomes invalid.</p> <p>To be more specific, equation 1 can become invalid if \(n_L &gt; n_T\) . This phenomena is called <strong>Total Internal Reflection</strong>, which means that no refraction is happening and the vector is reflecting off the surface. In this case, the equation for calculating the reflection vector is the one used.</p> <p><br/></p> <div class="row align-items-center mt-3"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/5-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/5-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Dark/5-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Dark/5.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/5-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/5-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/RefractionVectorCalculation/Light/5-1400.webp"/> <img src="/assets/img/Blog/RefractionVectorCalculation/Light/5.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> <p><br/></p> <p>Expressed another way, we can say that equation 1 is only valid when</p> \[sin \theta_L \leq \frac{n_T}{n_L}\] <p>Why ?</p> <p>Well, let’s prove it.</p> <p><br/></p> <h4 id="proof"><strong>Proof</strong></h4> <p><br/></p> <p>From equation 1, we can deduce that the equation becomes invalid when the quantity inside the radical becomes negative.</p> <p>Hence, equation 1 is valid only when</p> \[1-\frac{n_L^2}{n_T^2} (1-(N.L)^2) \geq 0\] <p>Rearranging the equation gives us:</p> \[\frac{n_L^2}{n_T^2} (1-(N.L)^2) \leq 1\] <p>We can divide both sides by \(\frac{n_L^2}{n_T^2}\) . This yields:</p> \[1-(N.L)^2 \leq \frac{n_T^2}{n_L^2}\] <p>Multiplying by -1 gives us:</p> \[(N.L)^2 -1 \geq - \frac{n_T^2}{n_L^2}\] \[(N.L)^2 \geq 1 - \frac{n_T^2}{n_L^2}\] <p>Now, since \(N.L = cos \theta_L\) , then</p> \[cos^2 \theta_L \geq 1 - \frac{n_T^2}{n_L^2}\] <p>We know that \(cos^2 \theta_L = 1 - sin^2 \theta_L\) . Hence,</p> \[1 - sin^2 \theta_L \geq 1 - \frac{n_T^2}{n_L^2}\] <p>Finally, rearranging the equation, multiplying by -1 and taking the square root in both sides gives us:</p> \[sin^2 \theta_L \leq \frac{n_T^2}{n_L^2}\] \[sin \theta_L \leq \frac{n_T}{n_L}\] <p>This completes the proof that equation 1 is only valid when</p> \[sin \theta_L \leq \frac{n_T}{n_L}\] <hr/> <p><br/></p> <h3 id="references">References</h3> <p><br/></p> <ul> <li>Chapter 6.4.2 - Mathematics for 3D Programming and Computer Graphics by Eric Lengyel</li> </ul> <p><br/></p> <hr/>]]></content><author><name></name></author><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Reflection Vector Calculation</title><link href="https://amrhmorsy.github.io/blog/2024/ReflectionVectorCalculation/" rel="alternate" type="text/html" title="Reflection Vector Calculation"/><published>2024-10-28T12:00:00+00:00</published><updated>2024-10-28T12:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2024/ReflectionVectorCalculation</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2024/ReflectionVectorCalculation/"><![CDATA[<p><br/></p> <h3 id="introduction-"><strong>Introduction</strong> <br/></h3> <p><br/></p> <div class="row align-items-center mt-3"> <div class="col-md-6"> When a beam of light hits the surface of an object, part of its energy is absorbed by the surface, part of its energy is reflected away and part of its energy may refract through the object itself. <br/> <br/> In this post, we will explore the mathematics behind calculating the reflection vector. <br/> <br/> Let: <br/> <br/> <li> \(L\) be the incoming light vector</li> <br/> <li> \(N\) be the normal of the surface,</li> <br/> <li> \(R\) be the reflection vector of \(L\),</li> <br/> <li> \(\theta_i\) be the angle of incidence, and </li> <br/> <li> \(\theta_r\) be the angle of reflection, and </li> <br/> <br/> We assume \(N\), \(L\) and \(R\) are normalized to unit length. </div> <div class="col-md-6"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/1-1400.webp"/> <img src="/assets/img/Blog/ReflectionVectorCalculation/Dark/1.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/1-1400.webp"/> <img src="/assets/img/Blog/ReflectionVectorCalculation/Light/1.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> </div> <p><br/></p> <p><br/></p> <h3 id="law-of-reflection-"><strong>Law of Reflection</strong> <br/></h3> <p><br/></p> <p>The law of reflection states that the angle of incidence is equal to the angle of reflection. That is,</p> \[\theta_i = \theta_r\] <p><br/></p> <div class="row align-items-center mt-3"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/2-1400.webp"/> <img src="/assets/img/Blog/ReflectionVectorCalculation/Dark/2.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/2-1400.webp"/> <img src="/assets/img/Blog/ReflectionVectorCalculation/Light/2.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> <p><br/></p> <p><br/></p> <h3 id="decomposition-of-vector-l-"><strong>Decomposition of Vector \(L\)</strong> <br/></h3> <p><br/></p> <p>To calculate the reflection vector \(R\), we first need to decompose the incoming light vector \(L\) in relation to the surface normal vector \(N\).</p> <p>The vector \(L\) has both a parallel component relative to \(N\) ; \(L_{||N}\) and a perpendicular component relative to \(N\) ; \(L_{⊥N}\) , such that</p> \[L = L_{||N} + L_{⊥N}\] <p>The parallel component of \(L\) along \(N\) is:</p> \[L_{||N} = (L.N)N = N cos \theta\] <p>The perpendicular component of \(L\) along \(N\) can be calculated by subtracting \(L_{||N}\) from \(L\) . That is,</p> \[L_{⊥N} = L - L_{||N} = L - (L.N)N\] <p><br/></p> <div class="row align-items-center mt-3"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/3-1400.webp"/> <img src="/assets/img/Blog/ReflectionVectorCalculation/Dark/3.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/3-1400.webp"/> <img src="/assets/img/Blog/ReflectionVectorCalculation/Light/3.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> <p><br/></p> <p>Just like we did with the incoming light vector \(L\), we are going to decompose the reflection vector \(R\) in relation to the surface normal vector \(N\).</p> <p>The vector \(R\) has both a parallel component relative to \(N\) ; \(R_{||N}\) and a perpendicular component relative to \(N\) ; \(R_{⊥N}\) , such that</p> \[R = R_{||N} + R_{⊥N}\] <p><br/></p> <div class="row align-items-center mt-3"> <figure class="col-md-12 text-center theme-img repo-img-light"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Dark/4-1400.webp"/> <img src="/assets/img/Blog/ReflectionVectorCalculation/Dark/4.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> <figure class="col-md-12 text-center theme-img repo-img-dark"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Blog/ReflectionVectorCalculation/Light/4-1400.webp"/> <img src="/assets/img/Blog/ReflectionVectorCalculation/Light/4.png" width="550" height="400" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </figure> </div> <p><br/></p> <p><br/></p> <h3 id="calculating-the-reflection-vector-r-"><strong>Calculating the Reflection Vector \(R\)</strong> <br/></h3> <p><br/></p> <p>Now, let’s calculate the reflection vector \(R\). Since</p> \[R = R_{||N} + R_{⊥N}\] <p>then we can calculate \(R\) by calculating its components \(R_{||N}\) and \(R_{⊥N}\) .</p> <p>By the law of reflection, the angle of incidence is equal to the angle of reflection; i.e \(\theta_i = \theta_r\)</p> <p>This means that the components of \(R\) is equal in magnitude to the components of \(L\), but they may have opposite directions.</p> <p>The perpendicular component of \(R\) along \(N\) ; \(R_{⊥N}\) has the same direction as the perpendicular component of \(L\) along \(N\) ; \(L_{⊥N}\) .</p> <p>The parallel component of \(R\) along \(N\) ; \(R_{||N}\) , is in the opposite direction of the parallel component of \(L\) along \(N\) ; \(L_{||N}\) .</p> <p>Hence, the reflection vector \(R\) can be calculated as follows:</p> \[R = L_⊥ - L_{||}\] \[R = L - (L.N)N - (L.N)N\] \[R = L - 2 (L.N)N\] <p><br/></p> <h3 id="implementation-">Implementation <br/></h3> <p><br/></p> <p>The GLM library has a built-in function that computes the reflection vector, given the normal and incident vector. Here’s the C++ code using the GLM library:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;glm/glm.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;glm/gtx/reflect.hpp&gt;</span><span class="cp">
</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="nf">compute_reflection_vector</span><span class="p">(</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">L</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">N</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">glm</span><span class="o">::</span><span class="n">reflect</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><br/></p> <h3 id="references">References</h3> <p><br/></p> <ul> <li>Chapter 6.4.1 - Mathematics for 3D Programming and Computer Graphics by Eric Lengyel</li> </ul> <p><br/></p> <hr/>]]></content><author><name></name></author><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>